\section{Introduction}\label{sec:introduction}
\epigraph{
``It is amazing what can be done
with just [...] some bitwise operations.''
}{
\emph{``Hacker's Delight''}, page \texttt{xiii}
\cite{Warren:2012:HD:2462741}
}


% TODO crazy fast instruction level parallelism
\subsection*{Crazy Ideas in Data Structures and Algorithms}
This essay is part of a seminar covering
ideas in computer science that feature a certain ``craziness''.
The content that will be presented here
might however not obviously fit into that description:

The underlying data structure is a bitword
-- the simplest interpretation of binary values possible.
Furthermore, all formulas are composed of simple logical operators,
without any complex (e.g. recursive) nesting involved.

None the less, the general principle of rejecting
common (high-level) abstract data types like boolean-arrays
for bitwords turns out to be a pretty crazy idea:
Single bits aren't directly accessible (requires copying and shifting)
and operations like increment will be used for
purposes differentiating a lot from their intended mathematical meaning.


\subsection*{Bitwords}
The most common term that will be used (and has been)
is a ``bitword'' or ``bitvector''.
It is simply defined as a sequence of bits with fixed length
that is indexed starting with $0$ from right to left
(so in \autoref{table:bitword} ``$\uparrow$'' refers to $x_3$).

However, it is important to remember that
there isn't any advanced interpretation (like a numerical value) to it
unless otherwise noted.
This still holds true while executing operations
which are designed for such interpretation (e.g. incrementing).
Therefore a good way to think of a bitvector
is a series of ``on'' (\lstinline$1$) and ``off'' (\lstinline$0$) values.

\begin{table}[h]
\begin{tabular}{rcl}
\lstinline$x = 1100 1011 001 $ & \lstinline$1$ & \lstinline$0000$\\
\multicolumn{2}{r}{rightmost \lstinline$1$ $\uparrow$}
& trailing \lstinline$0$s\\
\end{tabular}
\caption{A bitword \lstinline$x$ (length $16$)}
\label{table:bitword}
\end{table}

Terms like ``rightmost'' and ``trailing''
keep their conventional meaning (see \autoref{table:bitword})
-- the other ones will be introduced when required.


\subsection*{Logical Operators}
The basic behind all bit manipulation is boolean logic.
In order to mathematically express operations, the basic operators
\lstinline$NOT$: $\lnot$, \lstinline$OR$: $\lor$,
as well as \lstinline$AND$: $\land$ will be used.
These are interpreted in the well-known way:

\begin{table}[h]
\centering
\begin{tabular}{c|c||c|c|c}
  \lstinline$x$ & \lstinline$y$
& \lstinline$NOT$: $\lnot$ \lstinline$x$
& \lstinline$OR$: \lstinline$x$ $\lor$ \lstinline$y$
& \lstinline$AND$: \lstinline$x$ $\land$ \lstinline$y$\\
\hline\hline
  \lstinline$0$ & \lstinline$0$
& \lstinline$1$ & \lstinline$0$ & \lstinline$0$\\
\hline
  \lstinline$0$ & \lstinline$1$
& \lstinline$1$ & \lstinline$1$ & \lstinline$0$\\
\hline
  \lstinline$1$ & \lstinline$0$
& \lstinline$0$ & \lstinline$1$ & \lstinline$0$\\
\hline
  \lstinline$1$ & \lstinline$1$
& \lstinline$0$ & \lstinline$1$ & \lstinline$1$\\
\end{tabular}
\caption{Three basic boolean operators}
\label{table:logic}
\end{table}

Every formula composed of boolean operators maps
each configuration of input variables
\lstinline$x$, \lstinline$y$, $\dots$ to a boolean result.
A set of operators, which can be used to express any possible formula
is called a \emph{complete set of logical operators}.
Note that this is true for the set of operators in \autoref{table:logic}.

In order to express elaborated formulas as code,
\autoref{table:operators} introduces operators
found in common languages like \emph{C}.
It is important between do distinguish between
two ways of applying a logical operator to a bitword:

\begin{description}
\item[byte-level:] This represents the common usage:
The whole variable (at least one byte in size)
represents a single boolean value.

If and only if all bits are \lstinline$0$,
the value is considered to be false.

\item[bitwise:] This version is important for the techniques presented here.
As the name suggests every bit of the argument is treated independently.

Any operation on a variable (at least on byte in size)
is simultaneously executed for all bits,
with same indices of arguments being paired.
\end{description}

\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c}
function & mathematical & \emph{C}: byte-level & \emph{C}: bitwise\\
\hline
\lstinline$NOT$ & $\lnot$ & \lstinline$!$ & \lstinline$~$\\
\lstinline$OR$ & $\lor$ & \lstinline$||$ & \lstinline$|$\\
\lstinline$AND$ & $\land$ & \lstinline$&&$ & \lstinline$&$\\
\end{tabular}
\caption{Byte-level and bitwise operators in \emph{C}}
\label{table:operators}
\end{table}


\subsection*{Mathematical Operators}
In order to not only manipulate the entries of a bitword individually,
operations that interpret the whole sequence of bits are required.
Increment (\lstinline$INC$) and decrement (\lstinline$DEC$)
do so by treating the variable in a mathematical sense
and changing that value by $1$:

\begin{table}[h]
\centering
\begin{tabular}{c|c|c}
function & mathematical & \emph{C}\\
\hline
\lstinline$INC$ & $(x+1)$ & \lstinline$x+1$\\
\lstinline$DEC$ & $(x-1)$ & \lstinline$x-1$\\
\end{tabular}
\caption{Two basic mathematical operators}
\label{table:math}
\end{table}

Notice that the assigning notations \lstinline$x++$ and \lstinline$x--$
are deliberately ignored to make the code look more like ``formula''.
Furthermore two terms regarding these operations should be mentioned:
\emph{Carry} (and \emph{borrow}) are the bits
that are given to (or taken from) the next bit to the left
when facing \lstinline$1+1$ (\lstinline$0-1$ respectively).



































